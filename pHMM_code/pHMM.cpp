/*
	@author Sean Wilkerson  <wilkersm@muohio.edu>
*/

#include <vector>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <stdlib.h>
#include <cmath>
#include <string>
#include <sstream>
#include <utility>
#include <cstring>
#include <algorithm>
#include <assert.h>
#include <ctype.h>
#include "endProbFunc.hh"
#include "pHMM.hh"
#include "util_fun.h"

using namespace std;
using namespace boost;


// inline bool isACGT(char c, bool count_extra = false){
//    c = toupper(c);

//    // KARRO: Added 'Y' to blow
//    if (c == 'A' || c == 'C' || c == 'G' || c == 'T')
//      return true;

//    if  (count_extra && (c == 'R' || c == 'Y' || c == 'N'))
//      return true;

//    return false;
//  }


// double logsum(double x, double y){
//   double r;
  
//   if (x == neg_inf){
//     r = y;
//   }
//   else if (y == neg_inf){
//     r = x;
//   }
//   else{
//     if (x > y){
//       r = (x + log(1 + exp(y-x)));
//     }
//     else{
//       r = (y + log(1 + exp(x - y)));
//     }
//   }
//   return r;
// }

// double logsum(double x, double y, double z) {
//   return logsum( logsum(x,y), z );
// }



/*
opens an HMM from an existing file set
generated by this package

parameters:  Takes open ifstreams & will return them in a closed state if successful

Assumes file is intact and valid format, proper error checking and exception handling still needed

will die if file formatting is off to avoid hideously bad errors


*/

#include <iostream>
#include <iomanip>
char type2char(state_type t) {
  switch (t) {
  case mat : return 'M';
  case  ins : return 'I';
  case  del : return 'D';
  case  end : return 'E';
  }
  return ' ';
}

//**************************************
// The following functions are for debugging purposes only.
// If prob==ture then will print probabilities instead of log probabilities
template<class X>
void print_matrix(Matrix<X>& M, bool prob=true) {
  cout.setf(ios::fixed | ios::floatfield);
  cout.precision(2);
  cout << setw(6) <<  "Rows: " << M.getR() << "\n";
  cout << setw(6) <<  "Cols: " << M.getC() << "\n";
  for (int i=0; i < M.getR(); i++) {
    for (int j=0; j < M.getC(); j++) 
      cout << setw(6) <<  (prob ? exp(M[i][j]) : M[i][j]) << "\t";
    cout << setw(6) <<  "\n";
  }
}

void print_matrix_and_pointers(Matrix<double>& M, Matrix<state_type>& M2, int first_col = 0, int prob=true) {
  cout.setf(ios::fixed | ios::floatfield);
  cout.precision(4);
  cout << setw(6) <<  "Rows: " << M.getR() << "\n";
  cout << setw(6) <<  "Cols: " << M.getC() << "\n";
  for (int i=0; i < M.getR(); i++) {
    for (int j=first_col; j < M.getC(); j++) {
      cout << setw(6) <<  (prob ? exp(M[i][j]) : M[i][j]) << "(";
      switch (M2[i][j]) {
      case mat : cout << "M"; break;
      case ins : cout << "I"; break;
      case del : cout << "D"; break;
      case end : cout << "E"; break;
      }
      cout << ")\t";
    }
    cout << setw(6) <<  "\n";
  }
}

void print_vector_and_matrix(vector<double>& V, Matrix<double>& M, bool left=true, bool prob=true) {
  assert((int)V.size() == M.getR());
  cout.setf(ios::fixed | ios::floatfield);
  cout.precision(2);
  cout << setw(6) <<  "Rows: " << M.getR() << "\n";
  cout << setw(6) <<  "Cols: " << M.getC() << "\n";
  for (int i=0; i < M.getR(); i++) {
    if (left)
      cout << setw(6) <<  (prob ? exp(V[i]) : V[i]) << "\t\t";
    for (int j=0; j < M.getC(); j++) 
      cout << setw(6) <<  (prob ? exp(M[i][j]) : M[i][j]) << "\t";
    if (!left)
      cout << setw(6) <<  "\t" << (prob ? exp(V[i]) : V[i]);
    cout << setw(6) <<  "\n";
  }
}


void print_match_end(vMatrix& dpm, bool left, bool prob=true) {
  print_vector_and_matrix(dpm.End, dpm.Match, left, prob);
  print_vector_and_matrix(dpm.End, dpm.Delete, left, prob);
}
//*********************************************


void trace_path(vMatrix& dpm, int start_row, int start_state, int final_row, int final_state, int dir) {
  int current_row = start_row;
  int current_state = start_state;
  state_type current_type = mat;

  while ((dir < 0 && current_row <= final_row && current_state <= final_state) ||
	 (dir > 0 && current_row >= final_row && current_state >= final_state)) {
    double value;
    state_type next_state;
    switch (current_type) {
    case mat: value = dpm.Match[current_row][current_state]; next_state = dpm.MatchPointer[current_row][current_state]; break;
    case ins: value = dpm.Insert[current_row][current_state]; next_state = dpm.InsertPointer[current_row][current_state]; break;
    case del: value = dpm.Delete[current_row][current_state]; next_state = dpm.DeletePointer[current_row][current_state]; break;
    case end: value = dpm.End[current_row]; next_state = end; break;
    }

    cout << current_row << " " << current_state << " " << value << " (" << type2char(current_type) << ")\n";
    if (next_state != del)
      current_row -= dir;
    if (current_type != ins)
      current_state -= dir;
    current_type = next_state;
  }
}
      

double uniform_end_transition_probability(int num_states, int anchor_position, int anchor_coord, int dir) {
  if (dir == 1) {
    anchor_position = num_states - anchor_position;
    anchor_coord = num_states - anchor_coord;
  }
  return log(2.0*num_states*anchor_coord - num_states*num_states) - log(num_states*anchor_position - anchor_position*anchor_position);
}


//******************
void read_matrix(istream& fin, string HEADER, Matrix<double>& M) {
  string tmp;
  fin >> tmp;
  if (tmp != HEADER) {
    cerr << "Bad matrix in hmm file: " << HEADER << endl;
    exit(1);
  }

  for (int i=0; i < M.getR(); i++) 
    for (int j=0; j < M.getC(); j++) {
      fin >> tmp;
      M[i][j] = (tmp == "-inf" ? neg_inf : atoi(tmp.c_str()));
    }
}
		


pHMM::pHMM(char* hmm_file){
  ifstream ifp(hmm_file);

   if (!ifp.is_open()){
     cerr << "IO Error" << endl;
     // some exception goes here
   }
   //get name & size parameters

   string name, ancestor;
   int size;

   ifp >> name >> ancestor >> size;
   setName(name);
   setAncestor(ancestor);
   resize(size);

   read_matrix(ifp, "MATCH_EMISSION", m_eP);
   read_matrix(ifp, "INSERT_EMISSION", i_eP);
   read_matrix(ifp, "TRANSITIONS", t_P);
   
   ifp.close();
}


pHMM::~pHMM(){
}

// void pHMM::setBackgroundDistribution(){

//   for (int i = 0; i < (int) ALPHABET.size(); ++i){
//     q[i]= neg_inf;
//   }

//   q[A_MAP['A']] = log_bg_A;
//   q[A_MAP['C']] = log_bg_C;
//   q[A_MAP['G']] = log_bg_G;
//   q[A_MAP['T']] = log_bg_T;
//   q[A_MAP['R']] = logsum(log_bg_A, log_bg_G); // Purine  (A or G)
//   q[A_MAP['Y']] = logsum(log_bg_T, log_bg_C); // Pyrimidine (T or C)
//   q[A_MAP['N']] = log(1);


// }


/*
Bidirectional Viterbi Search
starts at obs[i] and searches in both directions to acheive optimal fit containing the point i
to the hmm.
TODO:
-add threading
 */
/*


Also proper handling of degenerate characters has been temporarily removed, and crudely compensated for
to allow for initial testing.
 */

Alignment pHMM::bDviterbi(SEQ* obs, int start_left, int start_right, int rel_left, int rel_right, double* normalized_bg_freq, endProbFunc* EPFunc, bool use_insertion) {
  int max_path_length_factor = 4;  // KARRO: The final path length (on one side) can be at most max_path_length_factor times
                                   // the number of ancestral bases on that side of the anchor.  This should be moved to consts.hh
                                   // The value 4 is totaly arbitrary for debugging; need to think through.

  // m_llen: Total length of observation path on the left INCLUDING left-most observation of the anchor.
  // m_rlen: Total length of observation path on the right INCLUDING right-most observation of the anchor.
  int m_llen = min(start_left + 1, max_path_length_factor*rel_left + 1);
  int m_rlen = min(SEQ_LEN(obs) - start_right, max_path_length_factor*(M-rel_right-1) + 1);

  int m_stop_left  =  start_left - m_llen + 1;
  int m_stop_right =  start_right + m_rlen - 1;  

  left = vMatrix(m_llen,M);
  right = vMatrix(m_rlen,M);

  int o2r_left = m_stop_left;   // "observation to row": observation i will match row i-o2r
  int o2r_right = start_right;

  // fill out the 2 viterbi matricies
  bDv_fill(obs, start_left, m_stop_left, left, rel_left,LEFT, o2r_left, normalized_bg_freq, use_insertion, EPFunc);
  bDv_fill(obs, start_right, m_stop_right, right, rel_right, RIGHT, o2r_right, normalized_bg_freq, use_insertion, EPFunc);

  // If either bDv_trace returns a value of neg_inf, then all paths have a zero probability
  Alignment left_align = bDv_trace(left, start_left, rel_left, LEFT);
  if (left_align.isEmptyPath())
    return Alignment();
  left_align.m_start += o2r_left;

  Alignment right_align = bDv_trace(right, start_right, rel_right, RIGHT);
  if (right_align.isEmptyPath())
    return Alignment();
  //right_align.m_start += o2r_right;

  int anchor_width = start_right - start_left + 1;
  return combine_alignment(left_align, right_align, anchor_width); // CHECK THIS!!!
}


/*

  Traceback Function
 */

// KARRO (1/20): Rewrote this to use the new Pointer matrices
Alignment pHMM::bDv_trace(vMatrix& dpm, int start, int qstate, int dir) {

  int first_row = dpm.maxEndPointerIndex;
  if (first_row == -1)  // There is no path of probability > 0
    return Alignment();

  double probScore = dpm.End[first_row];
  int first_state = dpm.EndPointer[first_row];
  stateVec pi;
 
  pi.push_back(end);
  int current_row = first_row;
  int current_state = first_state;
  state_type current_type = mat;

  while (true) {    
//     cout << "Trace position: " << current_row << " " << current_state << " " << type2char(current_type) << "(";
//     if (current_type == del) 
//       cout << dpm.Delete[current_row][current_state];
//     else
//       cout << dpm.Match[current_row][current_state];
//     cout << ")\n";

    state_type next_type;
    pi.push_back(current_type);
    if (current_state == qstate && current_type == mat)
      break;

    switch (current_type) {
    case mat : next_type = dpm.MatchPointer[current_row][current_state]; break;
    case ins : next_type = dpm.InsertPointer[current_row][current_state]; break;
    case del : next_type = dpm.DeletePointer[current_row][current_state]; break;
    default : assert(false);
    }
    
    if (current_type != ins)
      current_state -= dir;
    if (next_type != del)
      current_row -= dir;

    current_type = next_type;
  }

  if (dir == RIGHT) 
    reverse(pi.begin(), pi.end());

  //cout << endl;
  
  return dir == LEFT ? Alignment(probScore, first_state, first_row, pi) : Alignment(probScore, current_state, current_row, pi);
  
}


void pHMM::bDv_fill(SEQ* obs, int start, int end, vMatrix& dpm, int q_coord, int dir, int o2r, double* normalized_bg_freq, bool use_insertion, endProbFunc* EPFunc){
  //************************************
  // set up base_case: left-column
  // Principle: The last letter in the acchor is assigned the match state of the corresponding column with probability 1.
  // The rest can only be assigned to that match state if they are all insert.  No other deletes or matches.

  // Left and right are not symmetric with respect to insert states.
  // Problem: Insert state i relates to emission probabilities to the RIGHT of match statei.
  // This works fine when doing a right-search, but is a problem doing a left search.
  // int insert_adjust = (dir == LEFT ? -1 : 0);
 
  // Match the anchor letter to the first column (match state)
  int first_row = start - o2r;

  dpm.Match[first_row][q_coord] = 0;
  dpm.Insert[first_row][q_coord] = neg_inf;
  dpm.Delete[first_row][q_coord] = neg_inf;


  // Match the first non-achor letter to the first column (insert state -- from a match)
  if (inBounds(first_row + dir, end-o2r, dir)) {
    int obsv = getNucleotide(SEQ_AT(obs, first_row + dir + o2r));
    dpm.Insert[first_row+dir][q_coord] = dpm.Match[first_row][q_coord] + transProb(mat,ins) + i_eP[q_coord][obsv] - normalized_bg_freq[obsv];
    dpm.InsertPointer[first_row+dir][q_coord] = mat;

    dpm.Match[first_row+dir][q_coord] = neg_inf;
    dpm.Delete[first_row+dir][q_coord] = neg_inf;
  }

  // Match all ther non-anchor letters to the first colun (insert state -- from an insert state)
  if (inBounds(first_row+dir+dir, end-o2r, dir)) {
    for (int row=first_row + dir + dir; inBounds(row, end-o2r, dir); row += dir) {
      int obsv = getNucleotide(SEQ_AT(obs, row + o2r));
      dpm.Insert[row][q_coord] = dpm.Insert[row-dir][q_coord] + transProb(ins,ins) + i_eP[q_coord][obsv] - normalized_bg_freq[obsv];
      dpm.InsertPointer[row][q_coord] = ins;
      dpm.Match[row][q_coord] = neg_inf;
      dpm.Delete[row][q_coord] = neg_inf;
    }
  }
  
  dpm.End[first_row] = dpm.Match[first_row][q_coord] + EPFunc->getProb(q_coord); 
  dpm.EndPointer[first_row] = q_coord;
  dpm.maxEndPointerIndex = first_row;
  
  //********************************
  // Now the rest
  for (int row=start + dir - o2r, row_end = end-o2r; inBounds(row,row_end,dir); row += dir){  
    int obsv = getNucleotide(SEQ_AT(obs, row+o2r));     
    double norm = normalized_bg_freq[obsv];
    double prob;

    // KARRO (1/20): Making adjustments to below for efficiency and toset the Pointer matrices
    
    //***********************************
    // Calculate the match probability
    for (int j = q_coord+dir; (dir < 0 && j >= 0) || (dir > 0 && j < M); j+= dir) { // changed the loop iterator updating from ++j
      /* match emission [i][O] / background distribaution +
	Max of
	VMj-1(i-1) + transition_prob(match(j-1)->match[j])
	VIj-1(i-1) + transition_prob(ins(j-1)->match[j])
	VDj-1(i-1) + transition_prob(del(j-1)->match[j])
       */


      dpm.Match[row][j] = dpm.Match[row-dir][j-dir] + (transProb(mat,mat));
      dpm.MatchPointer[row][j] = mat;

      prob = dpm.Insert[row-dir][j-dir] + transProb(ins,mat);
      if (prob > dpm.Match[row][j]){
	dpm.Match[row][j] = prob;
	dpm.MatchPointer[row][j] = ins;
      }

      prob = dpm.Delete[row][j-dir] + transProb(del,mat);
      if (prob > dpm.Match[row][j]){
	dpm.Match[row][j] = prob;
	dpm.MatchPointer[row][j] = del;
      }

          
      // Adjust for emission probability
      //if (m_eP[j][obsv] != neg_inf) 
      dpm.Match[row][j] += emissionProb(j,obsv,mat) - norm;
      
    //***********************************
    // Calculate the delete probability

      
      // delete
      /*
	Max of

	VMj+1(i) + transition_prob(match[j-dir]->del[j])
	VIj+1(i) + transition_prob(ins[j-dir]->del[j]) = 0 so discarded
	VDj+1(i) + transition_prob(del[j-dir]->del[j])
       */
      
      dpm.Delete[row][j] = dpm.Match[row-dir][j-dir] + transProb(mat,del);
      dpm.DeletePointer[row][j] = mat;

      // insert -> delete
      prob = dpm.Delete[row][j-dir] + transProb(del,del);
      if (prob > dpm.Delete[row][j]){	
	dpm.Delete[row][j] = prob;
	dpm.DeletePointer[row][j] = del;
      }


    //***********************************
    // Calculate the insert probability
      // insert
      /*
	insert emission [row][O] / background + 
	Max of
	VMj(i-1) + transition_prob(match[j]->insert[j])
	VIj(i-1) + transition_prob(ins[j]->ins[j])
	VDj(i-1) + transition_prob(del[j]->ins[j]) = 0 so discarded
       */

      dpm.Insert[row][j] = dpm.Match[row-dir][j] + transProb(mat,ins);
      dpm.InsertPointer[row][j] = mat;

      prob = dpm.Insert[row-dir][j] + transProb(ins,ins);
      if (prob > dpm.Insert[row][j]){	
	dpm.Insert[row][j] = prob;
	dpm.InsertPointer[row][j] = ins;
      }

      // Adjust for emissions probability
      if (use_insertion)
	dpm.Insert[row][j] += emissionProb(j,obsv,ins) - norm;
      // otherwise it would be adjusted by norm - norm

    //***********************************
    // Calculate the end-state probability probability
      prob = dpm.Match[row][j] + EPFunc->getProb(j);
      if (prob > dpm.End[row]) {
	dpm.End[row] = prob;
	dpm.EndPointer[row] = j;

	if (dpm.End[row] >= dpm.End[dpm.maxEndPointerIndex])
	  dpm.maxEndPointerIndex = row;
      }
    }
  } 
}


/*

returns false is output fails
true if it does not
 */
bool pHMM::printToFile(string filename, bool logValues){
  vector<string> hmm_output;
  vector<string> extra_output;

  //  string hmmf = (string) filename + H_EXT;
  //  string extf (filename);
  //  hmmf.append(H_EXT);
  //  extf.append(H_EXT);
  //  extf.append(E_EXT);

  //  char *c_hmmf = new char [hmmf.size()+1];
  //  char *c_extf = new char [extf.size()+1];
  //  strcpy(c_hmmf,hmmf.c_str());
  //  strcpy(c_extf,extf.c_str());

  ofstream ofh(filename.c_str());
  //  ofstream ofe (c_extf);
 
  if (!ofh.good()){
    return false;
  }
  // format text for the .hmm.info
  
  if (!logValues) {
    ofh << "***WARNING: Bad file.  Values are probabilities, not log values.  Cannot be read.***\n";
    ofh.precision(4);
  }

  //format text for the .hmm
  //match emissions
  ofh << this->name << endl; //model name
  ofh << this->ANCESTOR << endl;  // ancestral sequence
  ofh << this->M << endl;    // size of model
  ofh << "MATCH_EMISSION" << endl;
  for (int j = 0; j < M; ++j){
    for (int a = 0; a < num_base_codes; ++a){
      ofh << (logValues ? emissionProb(j,a,mat) : exp(emissionProb(j,a,mat))) << '\t';
    }
    ofh << endl;
  }
  //insert emissions
  ofh << "INSERT_EMISSION" << endl;
  for (int j = 0; j < M; ++j){
    for (int a = 0; a < num_base_codes; ++a){
      ofh << (logValues ? emissionProb(j,a,ins) : exp(emissionProb(j,a,ins))) << '\t';
    }
    ofh << endl;
  }
  
  //transitions
  ofh << "TRANSITIONS" << endl;
  for (int j = 0; j < _TRANS; ++j){
    for (int a = 0; a < _TRANS; ++a){
      double v = transProb(j, a);
      ofh << (logValues ? v : exp(v)) << '\t';
    }
    ofh << endl;
  }

  // ofh << "END" << endl;
  
  //for (int i = 0;i<this->M;++i){
    //ofh << end_P[i] << '\t';
    
  // }

  ofh.close();

  return true;
}


// KARRO: The following are for use in referencing the second index
// of the align matricies, to help me keep track of which is which column 
// is which.
// const int ancestor_base = 0;
// const int modern_base = 1;

// void pHMM::buildFromAncestor(vector<string> &fd,string &modelName) {
//   //

//   // process ancestor
//   string buffer;
//   string ancestor_s = fd[0];
//   vector<string> atoks; //token vector
//   stringstream astrm(ancestor_s);
//   ANCESTOR = "";
  
//   while ( astrm >> buffer ){
//     atoks.push_back(buffer);
//   }
//   ancestor_s = atoks[1]; // cuts off leading processing info
//   int real_pos = -1;
 

//   // ancestor[i] = (base at position u, count of following insert letters)
//   vector< pair<char,int> > ancestor;
//   for (unsigned int f_pos = 0; f_pos < ancestor_s.size(); ++f_pos){
//     if (ancestor_s[f_pos] != INS_CHAR){ // not a dash
//       real_pos++;
//       pair<char,int> tpair (ancestor_s[f_pos],0);
//       ancestor.push_back(tpair);
//       ANCESTOR.push_back(ancestor_s[f_pos]);
//     }
//     else{  // its a dash
//       ancestor[real_pos].second++;
//     }
//   }
//   // end ancestor

//   // Normalize ancestral background distribution
//   //double total = 0;
//   //for (vector<double>::iterator i = q.begin(); i != q.end(); i++)
//   //  total += *i;
//   //for (vector<double>::iterator i = q.begin(); i != q.end(); i++)
//   //  *i = *i / total;


//   // do some init stuff
//   int tempM = ancestor_s.size();
//   // end init calls

//   // process  modern entries
//   // int maxpoint = 0; // keeping track of the maximum index used
//   vector< Matrix<char> > aligns; // 0 = ancestor 1 = modern
//   vector<pair<int, int> > endPoints;  // KARRO: Holds the start and end information for each modern instance 


//   // KARRO: Replaced this line with below: vector<double> endCounters(this->M,0);
//   vector<double> endCounters(tempM,0);
//   double totalCount = 0;

//   // KARRO?: changed the bound below from fd.size()-1 to fd.size()
//   for (int i = 1; i < (int)fd.size(); ++i){ // for each modern repeat

//     stringstream strm(fd[i]);
//     string tmp_string;
//     strm >> tmp_string >> tmp_string >> tmp_string;  // Skip the chromosome and modern start/stop info
    
//     int start, end;
//     strm >> start;    // Ancestral start coordinate
//     strm >> end;      // Ancestral stop coordinate

//     string modernSeq;
//     strm >> modernSeq;  // Modern repeat sequence
    
//     // KARRO: end cleanup -- excpet that tokens[5] must be replaed by modernSeq in rest of the loop
    
//     // KARRO: Replaced this line with below: if (start > 0 && end < M){
//     if (start > 0 && end < tempM){
//       endCounters[start]+= 1.0;
//       endCounters[end] += 1.0;
//       totalCount++;
//     }


//     Matrix<char> align(modernSeq.size(), 2);

//     // KARRO?: Got rid of the -1 in the loop bound.  (Correct?)
//     int apos = start;
//     for (int s=0; s < (int)modernSeq.size(); s++) { // KARRO: Should this be -1?
//       align[s][ancestor_base] = isLowerCase(modernSeq[s]) ? INS_CHAR : ancestor[apos++].first;
//       align[s][modern_base] = modernSeq[s];      
//       //maxpoint = max(maxpoint, s+start);   // KARRO?: s+start or s.end?
//     }

//     endPoints.push_back(make_pair(start, end));     // aligns[i][p][0] now correspoinds to ancestral coordinate
//     aligns.push_back(align);   // p + endPoints[i]
//     // Karro: End rewrite

//   } // end for each modern repeat


//   this->init(tempM, modelName); //initialize model matricies and other features

//   // Calculate the background distribution
//   int bg_total = 0;
//   for (string::iterator i = ANCESTOR.begin(); i != ANCESTOR.end(); i++) {
//     ancestral_bg[A_MAP[*i]]++;
//     bg_total++;
//   }

//   for (vector<double>::iterator i=ancestral_bg.begin(); i!=ancestral_bg.end(); i++)
//     *i = log(*i / bg_total);


//   //end rebuilding aligns and initializing model datastructures
//   //begin the actual estimation based on ancestor algorithm
//     // transition probs are count-based and thus need work
//   // this entire method is derived from Durbin, Eddy, et all, however where they use thier substition matricies
//   // we are dependent upon transition counts here
//   // Forumla is as follows
//   //
//   // EMj(a) = P(A|j=match state) = P(match | a) * p(a) / p(match)
//   // p(a) is the background distribution, p(match|a) is the count of matches vs non matches given the emission
//   // p(match) is a counts based ratio of matches vs non matches
//   // formula is respectively similar for insert emissions.
//   // states 0 and M+1 are for beginning/end, thus the working in M+2 space // KARRO: Removing the begin/end numbering; number match-state columns now.
//   vector<double> mCounts(this->M,0);
//   vector<double> iCounts(this->M,0);
//   vector<double> dCounts(this->M,0);

    
    
//   // get all counts neccessary
//   for (int k=0; k < (int)aligns.size(); k++) {
//     int p = endPoints[k].first - 1;
//     for (int j=0; j < (int)aligns[k].getR(); j++) { 
//       if (isLowerCase(aligns[k][j][modern_base])) // insert
// 	iCounts[p]++;  
//       else if (aligns[k][j][modern_base] == INS_CHAR) { // deletion
// 	dCounts[p]++;
// 	p++;
//       }      
//       else {
// 	p++;
// 	mCounts[p]++;
//       }
      
//       if (isACGT(aligns[k][j][modern_base], false)) { // Insert emission counts -- ignoring unknown characters
// 	if (isLowerCase(aligns[k][j][modern_base]))
// 	  i_eP[p][A_MAP[toupper(aligns[k][j][modern_base])]]++;
// 	else // KARRO?: Previously, this case was done only if [0] and [1] were equal -- I don't think thats right.  //if (aligns[k][j][1] == aligns[k][j][0]) 
// 	  m_eP[p][A_MAP[aligns[k][j][modern_base]]]++;
//       }
//     }
//   }	  

//   // calculating emissions tables using above counts
//   for (int j = 0 ; j < M; ++j){
//     double i_normal = 0;
//     double m_normal = 0;

//     // Karro: Changes the emission probabilities.  The probability of A,C,G,T now sum to 1, while th probability of R,Y,N are functions of the others
//     // Karro: NOTE HARDCODING!!!
//     for (int a = 0; a < 4; ++a){ 

//       // its possible i need to be taking logs here  
//       // KARRO (1/15): Added the +1s in the next two lines as a hack to ensure the probability is never zero.  This
//       // is important, but its not clear that this is the best way to do it.
//       i_eP[j][a] = (((i_eP[j][a] + 1) * exp(ancestral_bg[a])) / (iCounts[j] / (mCounts[j] + iCounts[j] + dCounts[j] + 1))); // see above comments for more readble
//       m_eP[j][a] = (((m_eP[j][a] + 1) * exp(ancestral_bg[a])) / (mCounts[j] / (mCounts[j] + iCounts[j] + dCounts[j] + 1))); // equation for this calculation 
//       i_normal += i_eP[j][a];
//       m_normal +=m_eP[j][a];
//     }

//     //normalization & logification
//     // note to self log(a/b) != log (a) - log(b)    // KARRO: Yes it is!!!  log(a-b) != log(a)/log(b).
//     // for the purposes of this so stop trying to do it 
//     // everytime you edit the code 

//     for (int a = 0; a < 4; ++a){
//       i_eP[j][a] = log(i_eP[j][a]) - log(i_normal); 
//       m_eP[j][a] = log(m_eP[j][a]) - log(m_normal);
//     }


//     i_eP[j][4] = logsum(i_eP[j][0], i_eP[j][2]);  // Set probability of R = A + G
//     m_eP[j][4] = logsum(m_eP[j][0], m_eP[j][2]);  // Set probability of R = A + G

//     i_eP[j][5] = logsum(i_eP[j][1], i_eP[j][3]);  // Set probability of Y = C + T
//     m_eP[j][5] = logsum(m_eP[j][1], m_eP[j][3]);  // Set probability of Y = C + T

//     i_eP[j][6] = 0;  // Set probability of N = 1
//     m_eP[j][6] = 0;  // Set probability of N = 1



//   }// end emission calcs


//   // transition tables
//   //end_P[i] = epfun(i,this->M);
  
//   // KARRO?: Is this next loop necessary?
//   int tP_count[4][4];
//   int tP_sum[4];  // Row sums for tp_count
//   for (int i = 0; i < _TRANS; ++i){
//     tP_sum[i] = 0;
//     for (int j = 0; j < _TRANS;++j){
//       tP_count[i][j] = 0;
//     }
//   }
//   //count transitions
//   // KARRO: Modified the j loop below to accomidate the shortened aligns[k] vectors.
//   for (int k = 0; k < (int)aligns.size(); ++k){   // KARRO: Changed the i index to k for consistency with above.
//     for (int j=1; j < aligns[k].getR(); j++) {
//       state_type last_state = getStateType(aligns[k][j-1][modern_base],aligns[k][j-1][ancestor_base]);
//       state_type this_state = getStateType(aligns[k][j][modern_base],aligns[k][j][ancestor_base]);

//       if (last_state != end && this_state != end ){
// 	tP_count[last_state][this_state]++;
// 	tP_sum[last_state]++;
//       }
//     }
//   }

//   // get log probabilities from counts
//   for (int i = 0; i < _TRANS; ++i){
//     for (int j = 0; j < _TRANS;++j)
//       t_P[i][j] = ((double)tP_count[i][j]) / tP_sum[i];
//   }

//   t_P[ins][del] = 0;
//   t_P[del][ins] = 0;
  
//   for (int i = 0 ; i < _TRANS; ++i){
//     double norm = 0;
//     for (int j = 0; j < _TRANS; ++j){
//       norm += t_P[i][j];
//     }
//     double log_norm = log(norm);
//     for (int j = 0; j < _TRANS;++j)
//       t_P[i][j] = log(t_P[i][j]) - log_norm;
//   }

// }// end build


state_type pHMM::getStateType(char base, char anc){
 
  if (base == '*' || anc == '*'){
    return end;
  }

 state_type s;
  if (base == INS_CHAR)
    s = del;
  else if (islower(base))
    s = ins;
  else
    s = mat;

  return s;
}

void pHMM::setAncestor(const string& ancestor) {
  ANCESTOR = ancestor;
  ancestral_bg = vector<double>(4, 0);
  
  int total = 0;
  for (string::iterator i=ANCESTOR.begin(); i!=ANCESTOR.end(); i++) {
    ancestral_bg[getNucleotide(*i)]++;
    total++;
  }

  for (vector<double>::iterator i=ancestral_bg.begin(); i!=ancestral_bg.end(); i++)
    *i = log(*i / total);
}

void pHMM::resize(int M) {
  this->M = M;

  end_P = vector<double>(M);
  i_eP = Matrix<double>(M, num_base_codes);
  m_eP = Matrix<double>(M, num_base_codes);
  t_P  = Matrix<double>(_TRANS, _TRANS);
}



bool pHMM::inBounds(int row , int stop, int dir){
  if (dir > 0){
    return (row <= stop);
  }
  else{
    return (row >= stop);
  }
}

//****************************************************************
// genSeq: Generate a random sequence as dictated by the model.
// Used for testin purposes.
// Function author: Karro
//****************************************************************

// Return a random integer based on the distribution D
// Assume elements of D sum to 1
// Probably should have done with boost rng
// Assumes srand has been called 
int rand_from_dist(vector<double> D) { 
  double total = exp(D[0]);
  double u = ((double)rand()) / RAND_MAX;
  int i = (state_type)0;

  while (total < u && i < (int)D.size()-1) 
    total += exp(D[++i]);

  return i;
}

// Let the HMM "generate" a random sequence.
// First string returns observations.
// Second string returns state-type deviation.
// Currently generates whole string -- cannot truncate the ends.
pair<string,string> pHMM::genSequence() {
  string s = "";
  string s2 = "";

  int i = 0;
  state_type current_state_type = mat;  // Assume we start in the right-most match state -- FIX
  while (i < M) {
    // Emit
    switch (current_state_type) {
    case mat:
      s += convertNucleotide((nucleotide)rand_from_dist(m_eP[i]));
      s2 += "M";
      break;
    case ins:
      s += convertNucleotide((nucleotide)rand_from_dist(i_eP[i]));
      s2 += "I";
      break;
    case del:
      s2 += "D";
      break;
    case end:
      cerr << "genSequence() ended up with an End case\n";
      exit(1);
    }

    current_state_type = (state_type)rand_from_dist(t_P[current_state_type]);
    if (current_state_type != ins) 
      i++;
  }

  return pair<string,string>(s, s2);
}


string pHMM::genBackground(int bg_length) {
  string s = "";

  for (int i=0; i < bg_length; i++) 
    s += convertNucleotide((nucleotide)rand_from_dist(ancestral_bg));

  return s;
}

tuple<int, int, double> pHMM::bDforward(SEQ* obs, int start_left, int start_right, int rel_left, int rel_right, double* normalized_bg_freq, endProbFunc* EPFunc, bool use_insertion) {
  int max_path_length_factor = 4;  // KARRO: The final path length (on one side) can be at most max_path_length_factor times
                                   // the number of ancestral bases on that side of the anchor.  This should be moved to consts.hh
                                   // The value 4 is totaly arbitrary for debugging; need to think through.

  // m_llen: Total length of observation path on the left INCLUDING left-most observation of the anchor.
  // m_rlen: Total length of observation path on the right INCLUDING right-most observation of the anchor.
  int m_llen = min(start_left + 1, max_path_length_factor*rel_left + 1);
  int m_rlen = min(SEQ_LEN(obs) - start_right, max_path_length_factor*(M-rel_right-1) + 1);

  int m_stop_left  =  start_left - m_llen + 1;
  int m_stop_right =  start_right + m_rlen - 1;  

  left = vMatrix(m_llen,M);
  right = vMatrix(m_rlen,M);

  int o2r_left = m_stop_left;   // "observation to row": observation i will match row i-o2r
  int o2r_right = start_right;

  // fill out the 2 viterbi matricies
  bDf_fill(obs, start_left, m_stop_left, left, rel_left,LEFT, o2r_left, normalized_bg_freq, use_insertion, EPFunc);
  bDf_fill(obs, start_right, m_stop_right, right, rel_right, RIGHT, o2r_right, normalized_bg_freq, use_insertion, EPFunc);

  int left_end = left.maxEndPointerIndex;
  int right_end = right.maxEndPointerIndex;

  return make_tuple(left_end + o2r_left, right_end + o2r_right, left.End[left_end] + right.End[right_end]);
}

void pHMM::bDf_fill(SEQ* obs, int start, int end, vMatrix& dpm, int q_coord, int dir, int o2r, double* normalized_bg_freq, bool use_insertion, endProbFunc* EPFunc){
  //************************************
  // This is an almost exact copy of bDv_fill, differing only in:
  // 1) Where bDv_fill take a max, this takes a sum
  // 2) There is no attempt to (or possibility of) returning a "best path" -- not relevant.
  //    Hence the "Pointer" matrices are ignored.
 
  // Match the anchor letter to the first column (match state)
  int first_row = start - o2r;

  dpm.Match[first_row][q_coord] = 0;
  dpm.Insert[first_row][q_coord] = neg_inf;
  dpm.Delete[first_row][q_coord] = neg_inf;


  // Match the first non-achor letter to the first column (insert state -- from a match)
  if (inBounds(first_row + dir, end-o2r, dir)) {
    int obsv = getNucleotide(SEQ_AT(obs, first_row + dir + o2r));
    dpm.Insert[first_row+dir][q_coord] = dpm.Match[first_row][q_coord] + transProb(mat,ins) + i_eP[q_coord][obsv] - normalized_bg_freq[obsv];

    dpm.Match[first_row+dir][q_coord] = neg_inf;
    dpm.Delete[first_row+dir][q_coord] = neg_inf;
  }

  // Match all ther non-anchor letters to the first colun (insert state -- from an insert state)
  if (inBounds(first_row+dir+dir, end-o2r, dir)) {
    for (int row=first_row + dir + dir; inBounds(row, end-o2r, dir); row += dir) {
      int obsv = getNucleotide(SEQ_AT(obs, row + o2r));
      dpm.Insert[row][q_coord] = dpm.Insert[row-dir][q_coord] + transProb(ins,ins) + i_eP[q_coord][obsv] - normalized_bg_freq[obsv];
      dpm.Match[row][q_coord] = neg_inf;
      dpm.Delete[row][q_coord] = neg_inf;
    }
  }
  
  dpm.End[first_row] = dpm.Match[first_row][q_coord] + EPFunc->getProb(q_coord); 
  dpm.maxEndPointerIndex = first_row;
  
  //********************************
  // Now the rest
  for (int row=start + dir - o2r, row_end = end-o2r; inBounds(row,row_end,dir); row += dir){  
    int obsv = getNucleotide(SEQ_AT(obs, row+o2r));     
    double norm = normalized_bg_freq[obsv];
    double prob1, prob2, prob3, adjust;

    //***********************************
    // Calculate the match probability
    for (int j = q_coord+dir; (dir < 0 && j >= 0) || (dir > 0 && j < M); j+= dir) { // changed the loop iterator updating from ++j
      /* match emission [i][O] / background distribaution +
	Max of
	VMj-1(i-1) + transition_prob(match(j-1)->match[j])
	VIj-1(i-1) + transition_prob(ins(j-1)->match[j])
	VDj-1(i-1) + transition_prob(del(j-1)->match[j])
       */

      adjust = emissionProb(j,obsv,mat) - norm;
      prob1 = dpm.Match[row-dir][j-dir] + (transProb(mat,mat)) + adjust;
      prob2 = dpm.Insert[row-dir][j-dir] + transProb(ins,mat) + adjust;
      prob3 = dpm.Delete[row][j-dir] + transProb(del,mat) + adjust;

      dpm.Match[row][j] = logsum(prob1, prob2, prob3);

    //***********************************
    // Calculate the delete probability

      
      // delete
      /*
	Max of

	VMj+1(i) + transition_prob(match[j-dir]->del[j])
	VIj+1(i) + transition_prob(ins[j-dir]->del[j]) = 0 so discarded
	VDj+1(i) + transition_prob(del[j-dir]->del[j])
       */
      
      prob1 = dpm.Match[row-dir][j-dir] + transProb(mat,del);
      prob2 = dpm.Delete[row][j-dir] + transProb(del,del);
      
      dpm.Delete[row][j] = logsum(prob1, prob2);

    //***********************************
    // Calculate the insert probability
      // insert
      /*
	insert emission [row][O] / background + 
	Max of
	VMj(i-1) + transition_prob(match[j]->insert[j])
	VIj(i-1) + transition_prob(ins[j]->ins[j])
	VDj(i-1) + transition_prob(del[j]->ins[j]) = 0 so discarded
       */

      adjust = use_insertion ? emissionProb(j,obsv,ins) - norm : 0;
      prob1 = dpm.Match[row-dir][j] + transProb(mat,ins) + adjust;
      prob2 = dpm.Insert[row-dir][j] + transProb(ins,ins) + adjust;

      dpm.Insert[row][j] = logsum(prob1, prob2);

    //***********************************
    // Calculate the end-state probability probability
      dpm.End[row] = logsum( dpm.End[row], dpm.Match[row][j] + EPFunc->getProb(j) );
    }
    if (dpm.End[row] >= dpm.End[dpm.maxEndPointerIndex])
      dpm.maxEndPointerIndex = row;
  } 
}
